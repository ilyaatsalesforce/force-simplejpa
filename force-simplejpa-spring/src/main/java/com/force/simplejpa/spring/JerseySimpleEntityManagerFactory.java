/*
 * Copyright, 2012, SALESFORCE.com
 * All Rights Reserved
 * Company Confidential
 */
package com.force.simplejpa.spring;

import javax.ws.rs.core.HttpHeaders;

import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Component;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientRequest;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
import com.sun.jersey.api.client.filter.ClientFilter;

import com.force.simplejpa.AuthorizationConnector;
import com.force.simplejpa.RestSimpleEntityManager;
import com.force.simplejpa.SimpleEntityManager;
import com.force.simplejpa.jaxrs.JerseyRestConnector;

/**
 * A Spring-based factory for request-scoped instances of {@link SimpleEntityManager} that use a {@link
 * JerseyRestConnector} for communications.
 * <p/>
 * TODO Add doc of how to configure in Spring context.
 *
 * @author dbuccola
 */
@Component("simpleEntityManagerFactory")
@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES)
@edu.umd.cs.findbugs.annotations.SuppressWarnings("ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD")
public class JerseySimpleEntityManagerFactory implements FactoryBean<SimpleEntityManager>, InitializingBean {
    private static final String DEFAULT_API_VERSION = "v26.0";

    /**
     * The following factory configuration is placed in static fields so it is shared by all.
     * <p/>
     * The static fields are somewhat unusual but compensate for the unfortunate fact that Spring creates a new factory
     * for each request. What we really want is an application-scoped factory with request-scoped beans generated by the
     * factory. What Spring does, however, is also give us request-scoped factories. :-(
     * <p/>
     * We use static fields to make the factory configuration effectively application scoped. This is helpful because if
     * the application is not careful they can do things that are really inefficient if the factory configuration was to
     * be request-scoped.
     */
    private static String apiVersion = DEFAULT_API_VERSION;
    private static Client client = new Client();
    private static AuthorizationConnector authorizationConnector = new RequestAuthorizationConnector();

    /**
     * A singleton ClientFilter for adding the authorization header. It is a stateless singleton on purpose. If you
     * start creating dynamic per-request instances you can accidentally end up with performance problems if you are not
     * careful. Having a singleton helps avoid performance accidents.
     */
    private static final ClientFilter authorizationFilter = new ClientFilter() {
        @Override
        public ClientResponse handle(ClientRequest clientRequest) {
            clientRequest.getHeaders().add(HttpHeaders.AUTHORIZATION, authorizationConnector.getAuthorization());
            return getNext().handle(clientRequest);
        }
    };

    /**
     * Sets the Salesforce API version used by the generated {@link SimpleEntityManager} instances.
     *
     * @param anApiVersion a Salesforce API version (for example: "v27.0")
     */
    public void setApiVersion(String anApiVersion) {
        apiVersion = anApiVersion;
    }

    /**
     * Sets the {@link Client} used by the generated {@link SimpleEntityManager} instances.
     * <p/>
     * Note that the given client is shared by all {@link SimpleEntityManager} instances and therefore must be thread
     * safe. {@link Client} is naturally thread safe so it shouldn't require any effort on your part.
     *
     * @param aClient a client
     */
    @Autowired
    public void setClient(Client aClient) {
        if (aClient == null) {
            throw new IllegalArgumentException("client is null");
        }
        client = aClient;
    }

    /**
     * Sets the {@link AuthorizationConnector} used by the generated {@link SimpleEntityManager} instances.
     * <p/>
     * Note that the given authorization connector is shared by all {@link SimpleEntityManager} instances and therefore
     * must be thread safe. Implementations of {@link AuthorizationConnector} will typically use thread-local storage or
     * HttpServletRequest context to achieve the thread safety.
     *
     * @param anAuthorizationConnector an authorization connector
     */
    @Autowired
    public void setAuthorizationConnector(AuthorizationConnector anAuthorizationConnector) {
        if (anAuthorizationConnector == null) {
            throw new IllegalArgumentException("authorizationConnector is null");
        }
        authorizationConnector = anAuthorizationConnector;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        if (!client.isFilterPreset(authorizationFilter)) {
            client.addFilter(authorizationFilter);
        }
    }

    @Override
    public SimpleEntityManager getObject() {
        WebResource instanceResource = client.resource(authorizationConnector.getInstanceUrl());
        WebResource dataResource = instanceResource.path("services/data/" + apiVersion);
        return new RestSimpleEntityManager(new JerseyRestConnector(dataResource));
    }

    @Override
    public Class<?> getObjectType() {
        return SimpleEntityManager.class;
    }

    @Override
    public boolean isSingleton() {
        return false;
    }
}
