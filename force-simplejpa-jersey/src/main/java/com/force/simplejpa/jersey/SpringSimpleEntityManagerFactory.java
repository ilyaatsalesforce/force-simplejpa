/*
 * Copyright, 2012, SALESFORCE.com
 * All Rights Reserved
 * Company Confidential
 */
package com.force.simplejpa.jersey;

import com.force.simplejpa.AuthorizationConnector;
import com.force.simplejpa.RestSimpleEntityManager;
import com.force.simplejpa.SimpleEntityManager;
import com.sun.jersey.api.client.Client;
import org.apache.commons.lang.Validate;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Component;

/**
 * A Spring-based factory for request-scoped instances of {@link SimpleEntityManager} that use a {@link
 * JerseyRestConnector} for communications.
 * <p/>
 * TODO Add doc of how to configure in Spring context. Especially when you have special needs. Need to make sure it is
 * request scoped.
 *
 * @author davidbuccola
 */
@Component("simpleEntityManagerFactory")
@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES)
@edu.umd.cs.findbugs.annotations.SuppressWarnings("ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD")
public class SpringSimpleEntityManagerFactory implements FactoryBean<SimpleEntityManager> {
    /**
     * The following factory configuration is placed in static fields so it is shared by all.
     * <p/>
     * The static fields are somewhat unusual but compensate for the unfortunate fact that Spring creates a new factory
     * for each request. What we really want is an application-scoped factory with request-scoped beans generated by the
     * factory. What Spring does, however, is also give us a request-scoped factory. :-(
     * <p/>
     * We use static fields to make the factory configuration effectively application scoped singleton. This is helpful
     * because if the application is not careful they can do things that are really inefficient if the factory
     * configuration is request-scoped.
     * <p/>
     * Also note that default values are established here so that extra spring configuration is not needed in simple use
     * cases. The autowiring is set to "not required" so that you only need to configure if you have special needs.
     */
    private static AuthorizationConnector authorizationConnector = new SpringRequestAuthorizationConnector();
    private static Client client = new JerseyClientFactory().newInstance(authorizationConnector);
    private static String apiVersion = null;

    /**
     * Sets the Salesforce API version used by the generated {@link SimpleEntityManager} instances.
     *
     * @param anApiVersion a Salesforce API version (for example: "v28.0")
     */
    public void setApiVersion(String anApiVersion) {
        apiVersion = anApiVersion;
    }

    /**
     * Sets the {@link Client} used by the generated {@link SimpleEntityManager} instances.
     * <p/>
     * Note that the given client is shared by all {@link SimpleEntityManager} instances and therefore must be thread
     * safe. {@link Client} is naturally thread safe so it shouldn't require any effort on your part.
     *
     * @param aClient a client
     */
    @Autowired(required = false)
    public void setClient(Client aClient) {
        Validate.notNull(authorizationConnector, "client must not be null");

        client = aClient;
    }

    /**
     * Sets the {@link AuthorizationConnector} used by the generated {@link SimpleEntityManager} instances.
     * <p/>
     * Note that the given authorization connector is shared by all {@link SimpleEntityManager} instances and therefore
     * must be thread safe. Implementations of {@link AuthorizationConnector} will typically use thread-local storage or
     * HttpServletRequest context to achieve the thread safety.
     *
     * @param anAuthorizationConnector an authorization connector
     */
    @Autowired(required = false)
    public void setAuthorizationConnector(AuthorizationConnector anAuthorizationConnector) {
        Validate.notNull(authorizationConnector, "authorizationConnector must not be null");

        authorizationConnector = anAuthorizationConnector;
    }

    @Override
    public SimpleEntityManager getObject() {
        return new RestSimpleEntityManager(new JerseyRestConnector(client, authorizationConnector.getInstanceUrl(), apiVersion));
    }

    @Override
    public Class<?> getObjectType() {
        return SimpleEntityManager.class;
    }

    @Override
    public boolean isSingleton() {
        return false;
    }
}
